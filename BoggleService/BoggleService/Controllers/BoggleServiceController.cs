using Boggle;
using BoggleService.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Threading;
using System.Web.Http;

namespace BoggleService.Controllers
{
    /// <summary>
    /// 
    /// </summary>
    public class BoggleServiceController : ApiController
    {
        /// <summary>
        /// Holds a collection unique Users, mapped according to their unique UserToken.
        /// </summary>
        private static Dictionary<string, User> Users = new Dictionary<string, User>();
        /// <summary>
        /// Holds a collection of each game, mapped according to their game ID's.
        /// </summary>
        private static Dictionary<string, Game> Games = new Dictionary<string, Game>();
        /// <summary>
        /// The pending game that's waiting to be started.
        /// </summary>
        private static Game PendingGame = new Game();
        /// <summary>
        /// Games are tracked by using a unique game ID, which is generated by appending this number
        /// on to the letter G. So, game ID's will look like this: "G11". This instance variable is
        /// set to increment whenever a new game is actually started.
        /// </summary>
        private static int CurrentGameNum = 0;
        /// <summary>
        /// Provides an object that will be used for locking down the methods.
        /// </summary>
        private static readonly object sync = new object();
        /// <summary>
        /// This HashSet holds a list of all of the words that are allowed in a Boggle game. It is
        /// filled in the static constructor.
        /// </summary>
        private static HashSet<string> dictionary = new HashSet<string>();


        /// <summary>
        /// Fills up the dictionary with all of the valid words that can be played in a Boggle game.
        /// </summary>
        static BoggleServiceController()
        {
            string[] text = File.ReadAllLines(AppDomain.CurrentDomain.BaseDirectory + "/dictionary.txt");
            foreach (string word in text)
            {
                dictionary.Add(word);
            }
        }


        /// <summary>
        /// Create a new user.
        ///
        /// If Nickname is null, or when trimmed is empty or longer than 50 characters, responds with
        /// status 403 (Forbidden). Otherwise, creates a new user with a unique user token and the
        /// trimmed Nickname.The returned user token should be used to identify the user in
        /// subsequent requests. Responds with status 200 (Ok).
        /// </summary>
        /// <param name="nickname">The name of the user to be registered</param>
        [Route("BoggleService/users")]
        public string PostMakeUser([FromBody]string nickname)
        {
            // Usernames can't be null, have no length, or be too long.
            if (nickname == null || nickname.Trim().Length == 0 || nickname.Trim().Length > 50)
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            // Built in functionality for testing purposes.
            else if (nickname.Trim()[0] == '@')
            {
                Thread.Sleep(10_000);
            }
            else if (nickname.Trim()[0] == '#')
            {
                throw new HttpResponseException(HttpStatusCode.InternalServerError);
            }
            string currentUserToken;
            lock (sync)
            {
                // Generate the unique user token.
                currentUserToken = Guid.NewGuid().ToString();

                // Construct the user with the appropriate information.
                User currentUser = new User()
                {
                    UserToken = currentUserToken,
                    Nickname = nickname,
                    WordsPlayed = new List<WordAndScore>()
                };
                // Add them into our database.
                Users.Add(currentUserToken, currentUser);
            }

            return currentUserToken;


        }

        /// <summary>
        /// Join a game.
        ///
        /// If UserToken is invalid, TimeLimit is less than 5, or TimeLimit is greater than 120,
        /// responds with status 403 (Forbidden). Otherwise, if UserToken is already a player in the
        /// pending game, responds with status 409 (Conflict). Otherwise, if there are no players in
        /// the pending game, adds UserToken as the first player of the pending game, and the
        /// TimeLimit as the pending game's requested time limit. Returns an object as illustrated
        /// below containing the pending game's game ID.Responds with status 200 (Ok) Otherwise, adds
        /// UserToken as the second player.The pending game becomes active and a new pending game
        /// with no players is created.The active game's time limit is the integer average of the
        /// time limits requested by the two players. Returns an object as illustrated below
        /// containing the new active game's game ID(which should be the same as the old pending
        /// game's game ID). Responds with status 200 (Ok).
        /// </summary>
        /// <param name="join">A request containing the user token and their desired time limit</param>
        [Route("BoggleService/games")]
        public JoinGameResponse PostJoinGame([FromBody]JoinGameRequest join)
        {
            User currentUser;
            // Time limits can't be too long or too short.
            if (join.TimeLimit < 5 || join.TimeLimit > 120)
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            lock (sync)
            {
                // If the user isn't registered, they can't join a game.
                if (!Users.TryGetValue(join.UserToken, out currentUser))
                {
                    throw new HttpResponseException(HttpStatusCode.Forbidden);
                }


                // If the pending game doesn't have a player one, add this player as the first player.
                JoinGameResponse response;
                if (PendingGame.Player1 == null)
                {
                    PendingGame.Player1 = new User()
                    {
                        UserToken = currentUser.UserToken,
                        Nickname = currentUser.Nickname,
                        DesiredTimeLimit = join.TimeLimit,
                        WordsPlayed = new List<WordAndScore>()
                    };
                    response = new JoinGameResponse()
                    {
                        GameID = "G" + CurrentGameNum,
                        IsPending = true
                    };
                    PendingGame.GameID = response.GameID;

                }
                // Otherwise, add the user as Player 2 and start the game up.
                else
                {
                    // Put the current user into the pending game as player 2.
                    PendingGame.Player2 = new User()
                    {
                        UserToken = currentUser.UserToken,
                        Nickname = currentUser.Nickname,
                        DesiredTimeLimit = join.TimeLimit,
                        WordsPlayed = new List<WordAndScore>()

                    };
                    // Construct the game as it's now active.
                    PendingGame.GameState = "active";
                    PendingGame.Board = new BoggleBoard().ToString();
                    PendingGame.TimeLimit = (PendingGame.Player1.DesiredTimeLimit + PendingGame.Player2.DesiredTimeLimit) / 2;
                    PendingGame.TimeLeft = PendingGame.TimeLimit;
                    PendingGame.TimeStarted = DateTime.Now.TimeOfDay;

                    // Add the pending game and then replace the PendingGame with an empty object.
                    Games.Add("G" + CurrentGameNum, PendingGame);
                    PendingGame = new Game();

                    response = new JoinGameResponse()
                    {
                        GameID = "G" + CurrentGameNum++,
                        IsPending = false
                    };

                }
                // Return the response that we previously constructed.
                return response;
            }

        }

        /// <summary>
        /// Cancel a pending request to join a game.
        ///
        /// If UserToken is invalid or is not a player in the pending game, responds with status 403
        /// (Forbidden). Otherwise, removes UserToken from the pending game and responds with status
        /// 204 (NoContent).
        /// </summary>
        /// <param name="UserToken">
        /// The unique identifying token for the player to be removed from the pending game
        /// </param>
        [Route("BoggleService/games")]
        public void PutCancelJoin([FromBody]string UserToken)
        {
            lock (sync)
            {
                // If the user doesn't exist, they can't cancel a request.
                if (!Users.TryGetValue(UserToken, out User currentUser))
                {
                    throw new HttpResponseException(HttpStatusCode.Forbidden);
                }
                // If the player isn't in a pending game, then they can't cancel a pending request.
                else if (PendingGame.Player1.UserToken != null && !PendingGame.Player1.UserToken.Equals(UserToken))
                {
                    throw new HttpResponseException(HttpStatusCode.Forbidden);
                }

                // Otherwise, set the pending game's first player to null.
                PendingGame.Player1 = null;
            }

        }

        /// <summary>
        /// Play a word in a game. If Word is null or empty or longer than 30 characters when
        /// trimmed, or if gameID or UserToken is invalid, or if UserToken is not a player in the
        /// game identified by gameID, responds with response code 403 (Forbidden). Otherwise, if the
        /// game state is anything other than "active", responds with response code 409 (Conflict)
        /// Otherwise, records the trimmed Word as being played by UserToken in the game identified
        /// by gameID.Returns the score for Word in the context of the game(e.g. if Word has been
        /// played before the score is zero). Responds with status 200 (OK). Note: The word is not
        /// case sensitive.
        /// </summary>
        /// <param name="gameID">The ID of the game that the word should be added to</param>
        /// <param name="request">
        /// Contains the UserToken of the user playing the word and the word itself
        /// </param>
        [Route("BoggleService/games/{gameID}")]
        public int PutPlayWord([FromUri] string gameID, PutWordRequest request)
        {
            // Check for all of the possible errors that could occur according to the API
            string UserToken = request.UserToken;
            string Word = request.Word.ToUpper();
            Game currentGame;
            // Can't have a null word.
            if (Word == null)
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            // Can't have no word or a word that's too long.
            else if (Word.Trim().Length == 0 || Word.Trim().Length > 30)
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            // If the game doesn't exist or the user, then throw.
            else if (!Games.TryGetValue(gameID, out currentGame) || !Users.TryGetValue(UserToken, out User temp))
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            // You can't play a word in a pending game or a game that isn't active.
            else if ((PendingGame.GameID != null && PendingGame.GameID.Equals(gameID)) || currentGame.GameState != "active")
            {
                throw new HttpResponseException(HttpStatusCode.Conflict);
            }
            // If the user isn't a player in the game, they can't play a word in the game.
            else if (!currentGame.Player1.UserToken.Equals(UserToken) && !currentGame.Player2.UserToken.Equals(UserToken))
            {
                throw new HttpResponseException(HttpStatusCode.Forbidden);
            }
            // Otherwise, play the word in the game and return it's score.
            BoggleBoard currentBoard = new BoggleBoard(Games[gameID].Board);
            WordAndScore wordBeingPlayed = new WordAndScore()
            {
                Word = Word
            };
            // If the word isn't in the dictionary, or can't be played on the board, it's score
            // should be negative one.
            if ((Word.Length > 2 && !dictionary.Contains(Word)) || !currentBoard.CanBeFormed(Word))
            {
                wordBeingPlayed.Score = -1;
            }
            else
            {
                // Otherwise, assign a point value to the word based on its length.
                switch (Word.Length)
                {
                    case 1:
                    case 2:
                        wordBeingPlayed.Score = 0;
                        break;
                    case 3:
                    case 4:
                        wordBeingPlayed.Score = 1;
                        break;
                    case 5:
                        wordBeingPlayed.Score = 2;
                        break;
                    case 6:
                        wordBeingPlayed.Score = 3;
                        break;
                    case 7:
                        wordBeingPlayed.Score = 5;
                        break;
                    default:
                        wordBeingPlayed.Score = 11;
                        break;
                }
            }

            // Determine your player number.
            bool arePlayerOne = DeterminePlayerNumber(currentGame, UserToken);
            if (arePlayerOne)
            {
                // If a player has already played the word, its point value should be zero.
                if (currentGame.Player1.WordsPlayed.Contains(wordBeingPlayed))
                {
                    wordBeingPlayed.Score = 0;
                }
                // Update the player's score and add it to the words that player has played.
                currentGame.Player1.Score += wordBeingPlayed.Score;
                currentGame.Player1.WordsPlayed.Add(wordBeingPlayed);
            }
            else
            {
                // If a player has already played the word, its point value should be zero.

                if (currentGame.Player2.WordsPlayed.Contains(wordBeingPlayed))
                {
                    wordBeingPlayed.Score = 0;
                }
                // Update the player's score and add it to the words that player has played.
                currentGame.Player2.Score += wordBeingPlayed.Score;
                currentGame.Player2.WordsPlayed.Add(wordBeingPlayed);
            }
            // Return the score that the word had
            return wordBeingPlayed.Score;
        }

        /// <summary>
        /// Determines if the player with the specified user token is the first player in the
        /// specified game. Assumes that the player is one of the player's in the game in the first place.
        /// </summary>
        /// <param name="game">The game the player is in</param>
        /// <param name="userToken">The player's user token</param>
        /// <returns></returns>
        private bool DeterminePlayerNumber(Game game, string userToken)
        {
            return game.Player1.UserToken.Equals(userToken);
        }

        /// <summary>
        /// Get game status information. If gameID is invalid, responds with status 403 (Forbidden).
        /// Otherwise, returns information about the game named by gameID as illustrated below.Note
        /// that the information returned depends on whether brief is true or false as well as on the
        /// state of the game. Responds with status code 200 (OK). Note: The Board and Words are not
        /// case sensitive.
        /// </summary>
        /// <param name="gameID">The ID of the game whose status will be checked</param>
        /// <param name="brief">Determines whether or not they want the brief response</param>
        /// <returns></returns>
        [Route("BoggleService/games/{gameID}/{brief}")]
        public Game GetGameStatus(string gameID, bool brief)
        {
            Game currentGame;
            Game response;
            lock (sync)
            {
                // If the game is pending, they will always get the same response.
                // If the game is active and they want a brief response, do the following.
                if (PendingGame.GameID != null && PendingGame.GameID.Equals(gameID))
                {
                    response = new Game()
                    {
                        GameState = "pending"
                    };
                    return response;
                }
                // If the game isn't pending and isn't on our list, return a Forbidden code.
                else if (!Games.TryGetValue(gameID, out currentGame))
                {
                    throw new HttpResponseException(HttpStatusCode.Forbidden);
                }
                // Determine the game state based on the amount of time left
                if (ComputeTimeLeft(currentGame) <= 0)
                {
                    currentGame.GameState = "completed";
                    currentGame.TimeLeft = 0;
                }
                // Now determine what our appropriate response should be.
                if (currentGame.GameState.Equals("active") && brief)
                {
                    // Copy over the state of the game.
                    response = new Game()
                    {
                        GameState = "active",
                        TimeLeft = ComputeTimeLeft(currentGame),
                        Player1 = DeepCopyUser(currentGame.Player1),
                        Player2 = DeepCopyUser(currentGame.Player2)
                    };


                    // Set all of the player info except for their score to null, so that it doesn't get serialized
                    response.Player1.Nickname = null;
                    response.Player1.WordsPlayed = null;

                    response.Player2.Nickname = null;
                    response.Player2.WordsPlayed = null;
                }
                // If the game is completed and they want a brief status, do the following.
                else if (currentGame.GameState.Equals("completed") && brief)
                {
                    // Copy over the state of the game.
                    response = new Game
                    {
                        GameState = "completed",
                        Player1 = DeepCopyUser(currentGame.Player1),
                        Player2 = DeepCopyUser(currentGame.Player2)

                    };

                    // Change all of the data in the response so when serialized it matches the brief response for a completed game.
                    response.Player1.Nickname = null;
                    response.Player1.WordsPlayed = null;

                    response.Player2.Nickname = null;
                    response.Player2.WordsPlayed = null;
                }
                // If the game is active and they want a complete response, do the following.
                else if (currentGame.GameState.Equals("active"))
                {
                    // Copy over the state of the current game, and deep copy the users.
                    response = new Game()
                    {
                        GameState = "active",
                        Board = currentGame.Board,
                        TimeLimit = currentGame.TimeLimit,
                        TimeLeft = ComputeTimeLeft(currentGame),
                        Player1 = DeepCopyUser(currentGame.Player1),
                        Player2 = DeepCopyUser(currentGame.Player2)
                    };

                    // For an active game, you don't want to serialize the words that the player
                    // played, so set them to null.
                    response.Player1.WordsPlayed = null;
                    response.Player2.WordsPlayed = null;

                }
                else
                {
                    // Copy over the state of the game, and deep copy over the players.
                    response = new Game()
                    {
                        GameState = "completed",
                        Board = currentGame.Board,
                        TimeLimit = currentGame.TimeLimit,
                        TimeLeft = ComputeTimeLeft(currentGame),
                        Player1 = DeepCopyUser(currentGame.Player1),
                        Player2 = DeepCopyUser(currentGame.Player2)
                    };
                }
                return response;
            }
        }
        /// <summary>
        /// Creates a deep copy of the passed in user.
        /// </summary>
        /// <param name="player">The user to be copied</param>
        /// <returns>A deep copy of the passed in user</returns>
        private User DeepCopyUser(User player)
        {
            User clone = new User()
            {
                UserToken = player.UserToken,
                Nickname = player.Nickname,
                Score = player.Score,
                WordsPlayed = new List<WordAndScore>(player.WordsPlayed)
            };

            return clone;
        }
        /// <summary>
        /// Computes the time left in a game by subtracting the current time of day from the sum of
        /// the time limit for the game and when that game started.
        /// </summary>
        /// <param name="g">The game who's time limit will be checked</param>
        /// <returns>
        /// The amount of time left in the game. Negative values indicate the game is over.
        /// </returns>
        private int ComputeTimeLeft(Game g)
        {
            return (int)(g.TimeStarted.TotalSeconds + g.TimeLimit)
                      - (int)(DateTime.Now.TimeOfDay.TotalSeconds);
        }
    }

}